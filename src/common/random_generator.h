/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*!
 * Copyright (c) 2017 by Contributors
 * \file random_generator.h
 * \brief Parallel random number generator.
 */
#ifndef MXNET_COMMON_RANDOM_GENERATOR_H_
#define MXNET_COMMON_RANDOM_GENERATOR_H_

#include <mxnet/base.h>
#include <random>
#include <new>

#if MXNET_USE_CUDA
#include <curand_kernel.h>
#include "../common/cuda_utils.h"
#endif  // MXNET_USE_CUDA

namespace mxnet {
namespace common {
namespace random {

template<typename Device, typename DType MSHADOW_DEFAULT_DTYPE>
class RandGenerator;

template<typename DType>
class RandGenerator<cpu, DType> {
 public:
  using RandomState = mshadow::PCGRandom64;
  // at least how many random numbers should be generated by one CPU thread.
  static const int kMinNumRandomPerThread;
  // store how many global random states for CPU.
  static const int kNumRandomStates;

  // implementation class for random number generator
  class Impl {
   public:
    typedef typename std::conditional<std::is_floating_point<DType>::value,
                                      DType, double>::type FType;

    explicit Impl(RandGenerator<cpu, DType> *gen, int state_idx)
        : state_(gen->states_ + state_idx) {}

    Impl(const Impl &) = delete;
    Impl &operator=(const Impl &) = delete;

    MSHADOW_XINLINE int rand() { return state_->operator()(); }

    MSHADOW_XINLINE FType uniform() {
      return dist_uniform(*state_);
    }

    MSHADOW_XINLINE FType normal() {
      return dist_normal(*state_);
    }

   private:
    using RandomState = RandGenerator<cpu, DType>::RandomState;
    RandomState *state_;
    // distributions can keep their internal states between calls.
    typename std::conditional<
      std::is_integral<DType>::value,
      std::uniform_int_distribution<DType>,
      mshadow::uniform_real_distribution<cpu, RandomState, FType>
    >::type dist_uniform;
    mshadow::normal_distribution<cpu, RandomState, FType> dist_normal;
  };

  static void AllocState(RandGenerator<cpu, DType> *inst) {
    inst->states_ = new RandomState[kNumRandomStates];
  }

  static void FreeState(RandGenerator<cpu, DType> *inst) {
    delete[] inst->states_;
  }

  MSHADOW_XINLINE void Seed(mshadow::Stream<cpu> *, uint32_t seed, uint32_t sequence_id_offset) {
    for (int i = 0; i < kNumRandomStates; ++i) {
      (states_ + i)->seed(seed, sequence_id_offset + i);
    }
  }

 private:
  RandomState *states_;
};  // class RandGenerator<cpu, DType>

template<typename DType>
const int RandGenerator<cpu, DType>::kMinNumRandomPerThread = 64;

template<typename DType>
const int RandGenerator<cpu, DType>::kNumRandomStates = 1024;

#if MXNET_USE_CUDA

template<typename DType>
class RandGenerator<gpu, DType> {
 public:
  // generates float and convert to half_t if DType is halt_t.
  using FType = typename std::conditional<sizeof(DType) <= 4, float, double>::type;
  // For float and half_t, 32-bit PCG generator is faster than 64-bit PCG generator.
  // To generate 64 random bits, two 32-bit random numbers are combined.
  using RandomState = mshadow::PCGRandom32;
  // at least how many random numbers should be generated by one GPU thread.
  static const int kMinNumRandomPerThread;
  // store how many global random states for GPU.
  static const int kNumRandomStates;

  class Impl {
   public:
    Impl &operator=(const Impl &) = delete;
    Impl(const Impl &) = delete;

    // Copy state to local memory for efficiency.
    __device__ explicit Impl(RandGenerator<gpu, DType> *gen, int state_idx)
        : state_(gen->states_ + state_idx), local_state_(*(gen->states_ + state_idx)) {}

    __device__ ~Impl() {
      // store the curand state back into global memory
      *state_ = local_state_;
    }

    MSHADOW_FORCE_INLINE __device__ int rand() {
      return local_state_();
    }

    MSHADOW_FORCE_INLINE __device__ FType uniform() {
      return dist_uniform(local_state_);
    }

    MSHADOW_FORCE_INLINE __device__ FType normal() {
      return dist_normal(local_state_);
    }

   private:
    using RandomState = RandGenerator<gpu, DType>::RandomState;
    RandomState *state_;
    RandomState local_state_;
    // distributions can keep their internal states between calls.
    typename std::conditional<
      std::is_integral<DType>::value,
      std::uniform_int_distribution<DType>,
      mshadow::uniform_real_distribution<gpu, RandomState, FType>
    >::type dist_uniform;
    mshadow::normal_distribution<gpu, RandomState, FType> dist_normal;
  };  // class RandGenerator<gpu, DType>::Impl

  static void AllocState(RandGenerator<gpu, DType> *inst) {
    CUDA_CALL(cudaMalloc(&inst->states_,
                         kNumRandomStates * sizeof(mshadow::PCGRandom32)));
  }

  static void FreeState(RandGenerator<gpu, DType> *inst) {
    CUDA_CALL(cudaFree(inst->states_));
  }

  void Seed(mshadow::Stream<gpu> *s, uint32_t seed, uint32_t sequence_id_offset);

 private:
  RandomState *states_;
};  // class RandGenerator<gpu, DType>

#endif  // MXNET_USE_CUDA

}  // namespace random
}  // namespace common
}  // namespace mxnet
#endif  // MXNET_COMMON_RANDOM_GENERATOR_H_
